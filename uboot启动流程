// 从u-boot.lds分析：
ENTRY(_start)
//起始地址不在lds中，经查找，在vectors.S中：

_start:

#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
	.word	CONFIG_SYS_DV_NOR_BOOT_CFG
#endif

	b	reset
        -> start.S中:
        -> reset:
	    b	save_boot_params
            ->ENTRY(save_boot_params)
	            b	save_boot_params_ret		@ back to my caller
            ENDPROC(save_boot_params)
	            .weak	save_boot_params
            // ENTRT定义函数入口，ENDPROC定义函数结束点。共同组成，有头有尾。
            // 同时.weak 弱定义，方便其他覆盖
            ->save_boot_params_ret:
                ->save_boot_params_ret函数段
                bl	cpu_init_cp15
                    ->设置CP15寄存器：缓存、MMU、TLB和可能设置I-cache
	            bl	cpu_init_crit
                    -> b lowlevel_init
                        -> lowlevel_init.S文件
                        lowlevel_init

                bl _main(无用了)


	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq

	.globl	_undefined_instruction
	.globl	_software_interrupt
	.globl	_prefetch_abort
	.globl	_data_abort
	.globl	_not_used
	.globl	_irq
	.globl	_fiq

// PC寄存器是CPU中的一个特殊寄存器，也是CPU中最重要的寄存器之一。
// 它存储的是指令的地址，CPU在执行指令时会不断地从PC寄存器中读取下一条指令的地址。
// 在执行完当前指令后，CPU会自动将PC寄存器的值加上当前指令的长度，
// 以便于执行下一条指令。




// reset函数段
reset:
	/* Allow the board to save important registers */
	b	save_boot_params
save_boot_params_ret:

	mrs	r0, cpsr
	and	r1, r0, #0x1f		@ mask mode bits
	teq	r1, #0x1a		@ test for HYP mode
	bicne	r0, r0, #0x1f		@ clear all mode bits
	orrne	r0, r0, #0x13		@ set SVC mode
	orr	r0, r0, #0xc0		@ disable FIQ and IRQ
	msr	cpsr,r0

    // cpsr寄存器 当前程序状态寄存器设置为SVC模式
    // 1. mrs r0, cpsr (特殊)将CPSR的值移动到r0
    // 2. and r1, r0, #0x1f 按位与运算，将r0与0x1f与运算后保存在r1. 获得cpsr模式位
    // 3. teq r1, #0x1a 将r1与0x1a判断相等性，作为下面的条件，判断是否为HYP模式
    // 4. bicne r0, r0, #0x1f ne为上面的结果notequal，0x1f按位取反后，与上r0，再保存进r0
    //   等于清零模式位的0~4
    // 5. orrne r0, r0, #0x13，将r0与0x13按位或，再写回r0，即设置为Supervisor(SVC)模式
    // 6. orr r0, r0, #0xc0， 将bit6，7置1，禁止IRQ,FIQ
    // 7. msr cpsr, r0 将r0 move回cpsr

/*
 * Setup vector:
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
// 这一块应该没执行
// 设置中断中断向量表 
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
	/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
	bic	r0, #CR_V		@ V = 0
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register

	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
#endif

// 这一块应该没执行
	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_cp15
	bl	cpu_init_crit
#endif

	bl	_main
